---
title: "Mfuzz clustering of SAM data, ALL significant genes"
format: html
date: "2025-09-22"
bibliography: ../../../refs-stat-anal.bib
execute:
  fig-format: png
  fig.dpi: 300
---

The aim of this code is to fuzzy-cluster genes using Mfuzz package [@futschikNoiserobustSoftClustering2005; @kumarMfuzzSoftwarePackage2007]

Comparisons to day one (penultimate day of cold)


/media/mj/ANTIX-LIVE/2024_04_01.counts.PS
/media/mj/ANTIX-LIVE/expr-anal2powt

http://mfuzz.sysbiolab.eu/
https://support.bioconductor.org/p/9156659/ # uśrednianie reps i użycie vst
https://support.bioconductor.org/p/111294/ # info o cpm od developerów
https://support.bioconductor.org/p/9156710/ # garść info od Love



Built with R version `r getRversion()`

## R Preliminaries

Environment cleaning and set-up

```{r setup}
#| include: false
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(root.dir = "/home/mj/project1-stat/vs-day-one/sam/scripts")
```

```{r packages}
#| eval: false
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Mfuzz")
BiocManager::install("marray")
BiocManager::install("limma")
```

```{r}
#| output: false

# Clean working directory
rm(list=ls())
```

:::{.callout-note}
## For a given number of significant genes repeating entire code is not required

Loading object (created in `cleanup2`) in `check real` chunk is sufficient
:::

## Create ExpressionSet from DESeq2 results

### Load ALL significant genes

```{r load}
load("../rdata-saved/sigs_all_SAM1.RDa")
```

### Extract significant genes' IDs

```{r sigs}

original_names <- grep("^[sa]", ls(), value = TRUE)

invisible(
  lapply(original_names, function(name) {
  obj <- get(name)
  
  result = rownames(obj)
  
  new_name <- paste0("ids.", name)
  assign(new_name, result, envir = .GlobalEnv)  # save new object
    }
  )
)

rm(list=ls(pattern = "^[sa]")) # remove original objects
rm(original_names)
```

### Join vectors and remove duplicates

```{r join}

vectors <- mget(ls(pattern = "^ids.*"))

# concatenate and remove duplicates
joined_ids <- unique(unlist(vectors))

rm(list=ls(pattern = "^ids.*")) # remove intermediate objects

```

### Load counts and normalize them using VST

```{r read data, cache=TRUE}
load("../../../input-data/rdata/counts_and_metadata.RDa")

# previously prepared range data
library("GenomicRanges")
load("../../../input-data/rdata/ranges.RDa")

# make variable for averaging
coldata$forAverage <- factor(paste0(coldata$line, ".", coldata$day, coldata$time))

# Check if files are in concert
all(rownames(coldata) %in% colnames(cts))
all(rownames(coldata) == colnames(cts))
```

### Change samples' order

```{r sort}
# sort colData
coldata.srt <- coldata[order(rownames(coldata)), ]

# sort counts columns
cts.srt <- cts[, rownames(coldata.srt)]

# Check if files are in concert
all(rownames(coldata.srt) %in% colnames(cts.srt))
all(rownames(coldata.srt) == colnames(cts.srt))

# remove original objects
rm(list=c("cts", "coldata"))
```

### Subset SAM data

Subsetting is done at the level of raw data (counts and coldata).
```{r subset SAM data}
# subset coldata to contain only sam data
coldata.sam=subset(coldata.srt, tissue=="sam")

# check
dim(coldata.sam)

# vector of sample names to keep - needed to select columns from count file
keep.sam=rownames(coldata.sam)

# check - only samples named "s..." should remain
keep.sam
length(keep.sam)

# subsetting counts
cts.sam=subset(cts.srt, select=keep.sam)

# check
dim(cts.sam)
colnames(cts.sam)

# Check if counts and coldata are in concert
all(rownames(coldata.sam) %in% colnames(cts.sam))
all(rownames(coldata.sam) == colnames(cts.sam))
```

### Create DESeq2 object

```{r dds, cache=TRUE}
#| output: false
#| message: false
library("DESeq2")
# create dataset, design included only for command completeness
dds = DESeqDataSetFromMatrix(countData=cts.sam, colData=coldata.sam, rowRanges=gzakresy, design= ~ line+time)

# check for missing values
any(is.na(counts(dds)))

# check
table(colData(dds)$tissue)
```

### Pre-filtering

```{r pre-filtering, cache=TRUE}
# at least 3 samples with a count of 10 or higher
keep <- rowSums(counts(dds) >= 10) >= 3
dds.f <- dds[keep,]

# check
dim(dds.f)

# what percent of genes remained?
100*(dim(dds.f)[1]/dim(dds)[1])
```

```{r normalize, cache=TRUE}
vsd = varianceStabilizingTransformation(dds.f, blind=TRUE)
```

```{r cleanup}
# objects to keep
keep <- c("vsd", "joined_ids")

# remove everything else
rm(list = setdiff(ls(), keep))
```

### Select counts for sigs

```{r counts}
# select sigs
vsd.sigs = vsd[rownames(vsd) %in% joined_ids, ]

# varMetadata - description of variables
metadata=data.frame(labelDescription=c("pooled sample", "letter", "tissue", "line", "hour of pooling", "sample number", "day", "replication", "condition", "id", "reads [million]", "batch [sequencing]", "million of reads binned", "grouping variable for averaging", "sizeFactor"), row.names=colnames(colData(vsd.sigs)))

# metadata
phenoData=new("AnnotatedDataFrame", data=as.data.frame(colData(vsd.sigs)), varMetadata=metadata)
phenoData

## check
# sampleNames(phenoData)
# pData(phenoData)
# varMetadata(phenoData)
# head(pData(phenoData))

# make ExpressionSet
vsd.eset <- ExpressionSet(assayData=assay(vsd.sigs), phenoData=phenoData)
```

### Averaging and standardizing

```{r avg and std}
library(limma)

# average reps
average = t(avereps(t(exprs(vsd.eset)), ID = vsd.eset$forAverage)) # output is a matrix

# check
dim(average)
dim(vsd.eset)

## make new phenoData
phenoDataAve = phenoData[!duplicated(vsd.eset$forAverage), ]
rownames(phenoDataAve)= phenoDataAve$forAverage

library(dplyr)

pdata_sorted <- pData(phenoDataAve) |>
  arrange(line, day, time)

# recreate AnnotatedDataFrame:
pData(phenoDataAve) <- pdata_sorted

# sort counts columns
average.srt <- average[, rownames(pData(phenoDataAve))]

all(rownames(pData(phenoDataAve) ) %in% colnames(average.srt))
all(rownames(pData(phenoDataAve) ) == colnames(average.srt))

vsd.eset.ave=ExpressionSet(assayData=average.srt, phenoData=phenoDataAve)

# standardise
library(Mfuzz)
vsd.eset.ave.std=standardise(vsd.eset.ave)

# check
head(exprs(vsd.eset.ave.std))

```

### Standardising and averaging

```{r std and ave}
library(limma)

# standardise
library(Mfuzz)

vsd.eset.std=standardise(vsd.eset)

# average reps
average.std = t(avereps(t(exprs(vsd.eset.std)), ID = vsd.eset.std$forAverage)) # output is a matrix

# check
dim(average.std)
dim(vsd.eset.std)

## make new phenoData
phenoDataAve = phenoData[!duplicated(vsd.eset.std$forAverage), ]
rownames(phenoDataAve)= phenoDataAve$forAverage

library(dplyr)

pdata_sorted <- pData(phenoDataAve) |>
  arrange(line, day, time)

# recreate AnnotatedDataFrame:
pData(phenoDataAve) <- pdata_sorted

# sort counts columns
average.std.srt <- average.std[, rownames(pData(phenoDataAve))]

all(rownames(pData(phenoDataAve) ) %in% colnames(average.std.srt))
all(rownames(pData(phenoDataAve) ) == colnames(average.std.srt))

vsd.eset.std.ave=ExpressionSet(assayData=average.std.srt, phenoData=phenoDataAve)
```

### Saving and cleanup

Correct order of operations (standardization, averaging) will be decided later

```{r cleanup2}
# objects to keep
keep <- c("vsd.eset.ave.std", "vsd.eset.std.ave")

# remove everything else
rm(list = setdiff(ls(), keep))

save(vsd.eset.std.ave, file="../rdata-saved/vsd.eset.std.ave.samALLsig.RDa")
save(vsd.eset.ave.std, file="../rdata-saved/vsd.eset.ave.std.samALLsig.RDa")
```

## Clustering, test for vsd.eset.ave.std

### Estimate fuzzification parameters

```{r estimate m}
# objects to keep
keep <- c("vsd.eset.ave.std")

# remove everything else
rm(list = setdiff(ls(), keep))

# fuzzification parameter
m1 <- mestimate(vsd.eset.ave.std)

m1
```

```{r estimate c}
# # using estimated m
# 
# cl1=mfuzz(vsd.eset.std, c=16, m=m1)
# 
# pdf("cl16_104R.pdf")
# #mfuzz.plot2(vsd.eset.std, cl=cl1, x11 = FALSE, single = 1, time.labels = colnames(vsd.eset.std), cex.axis = 0.6, las = 2)
# #mfuzz.plot2(vsd.eset.std, cl=cl1, x11 = FALSE, single = 1, time.labels = colnames(vsd.eset.std))
# mfuzz.plot2(vsd.eset.std, cl=cl1, mfrow=c(4,4), x11 = FALSE)
# dev.off()
```

### Estimate m using `partcoef`

```{r parameters}
## Deciding on cluster parameters ##
# m is already estimated
## TAKEN FROM partcoeff DESCRIPTION IN MANUAL
vsd.random=randomise(vsd.eset.ave.std)

tmpR=partcoef(vsd.random, crange=seq(7, 30, 1), mrange=seq(1.05, 1.45, 0.05))

F <- tmpR[[1]];F.n <- tmpR[[2]];F.min <- tmpR[[3]]
F > 1.01 * F.min

# it seems that value given by mestimate is too small, at least 1.1 must be used

library(Mfuzz)
# draw and save legend (uses modified function as this from package not work)
source("../../../colorbar.R")
pdf("colorbar.pdf", width=2, height=7)
colorBar()
dev.off()
```

```{r check random}
# RANODM

##############################
# Adjust parameters manually #
##############################

# c_val <- 4 ; m_val <- 1.05 # uniform partitioning
# c_val <- 8 ; m_val <- 1.05 # Non uniform partition (too low m value)
# c_val <- 16 ; m_val <- 1.05 # Non uniform partition (too low m value) but empty cluster present
# c_val <- 4 ; m_val <- 1.15 # produces uniform partitioning
# c_val <- 8 ; m_val <- 1.15 # produces uniform partitioning
# c_val <- 16 ; m_val <- 1.15 # produces uniform partitioning

# MFuzz analysis using variables above
cl <- mfuzz(vsd.random, c = c_val, m = m_val)

# dynamic naming of objects
filename <- paste0("cl", c_val, "_", m_val, "R.pdf")

pdf(filename)
mfuzz.plot2(vsd.random, cl = cl, mfrow = c(4, 2), x11 = FALSE)
dev.off()

```

### Automatic check for given combinations of c and m. Two methods.

```{r c auto}
library(Mfuzz)
library(parallel)

# -------------------------------------------------
# 1. Funkcja wykonująca pojedynczy krok
# -------------------------------------------------
run_one_c <- function(m_val) {
  # Nazwa pliku PDF (z dwoma miejscami po przecinku, żeby uniknąć np. "1.250")
  filename <- sprintf("c_m%.2f.pdf", m_val)

  # Otwórz urządzenie graficzne, a na końcu na pewno je zamknij
  pdf(filename)
  on.exit(dev.off(), add = TRUE)   # gwarancja zamknięcia przy błędzie

  # Wywołanie Twojej funkcji cselection
  c_res <- cselection(vsd.eset.ave.std,
                       m      = m_val,
                       crange = seq(15, 35, 1),
                       repeats = 10,
                       visu   = TRUE)

  # Zwróć listę z kluczem i wynikiem
  list(key = sprintf("c%.2f", m_val), res = c_res)
}

# -------------------------------------------------
# 2. Przygotowanie wektora parametrów
# -------------------------------------------------
m_vals <- seq(1.25, 1.45, by = 0.05)

# -------------------------------------------------
# 3. Liczba rdzeni (zostawiamy jeden wolny)
# -------------------------------------------------
n_cores <- detectCores() - 1

# -------------------------------------------------
# 4. Równoległe wywołanie
# -------------------------------------------------
out_list <- mclapply(m_vals, run_one_c, mc.cores = n_cores)

# -------------------------------------------------
# 5. Budowa listy wyników w żądanym formacie
# -------------------------------------------------
c_results <- setNames(
  lapply(out_list, `[[`, "res"),
  sapply(out_list, `[[`, "key")
)

# Teraz np. c_results[["c1.30"]] zawiera wynik dla m = 1.30
```


```{r dmin auto}
library(Mfuzz)
library(parallel)

# Twoja funkcja – opakowujemy całą logikę w jedną funkcję
run_one_m <- function(m_val) {
  # przygotuj nazwę pliku
  filename <- sprintf("Dmin_m%.2f.pdf", m_val)

  # otwórz urządzenie graficzne, wykonaj obliczenia, zamknij je
  pdf(filename)
  on.exit(dev.off(), add = TRUE)   # gwarantuje zamknięcie nawet przy błędzie

  # wywołanie Twojej funkcji Dmin (zakładam, że jest już załadowana)
  dmin_res <- Dmin(vsd.eset.ave.std,
                   m      = m_val,
                   crange = seq(7, 40, 1),
                   repeats = 10,
                   visu   = TRUE)

  # zwróć listę z wynikiem i kluczem
  list(key = sprintf("m%.2f", m_val),
       res = dmin_res)
}

# wektor wartości m
m_vals <- seq(1.15, 1.45, by = 0.05)
# m_vals <- 1.45

# liczba rdzeni, które chcesz wykorzystać
n_cores <- detectCores() - 1   # zostawiamy jeden wolny dla systemu

# uruchomienie równoległe
out_list <- mclapply(m_vals, run_one_m, mc.cores = n_cores)

# przekształcenie do listy wyników w takiej samej formie jak w pętli for
dmin_results <- setNames(
  lapply(out_list, `[[`, "res"),
  sapply(out_list, `[[`, "key")
)

# gotowe! dmin_results[[ "m1.15" ]] zawiera wynik dla m = 1.15 itd.
```

```{r check real}
## Code for testing various values of c and m in one go ##
# For this purpose uncomment plotting part

library(Mfuzz)

## Parameters chosen by PI

c_vals = 10 # Dmin
m_vals = 1.25 # Dmin


## Uncomment on new session
# load("../rdata-saved/vsd.eset.ave.std.samALLsig.RDa")
source("mfuzz.plot2_separate_lines.R") # modified plotting function, tailored to separate lines

# lista wyników
results <- list()

# loop for given combinations of c and m
for (c_val in c_vals) {
  for (m_val in m_vals) {

    set.seed(1) # for reproducibility

    # clustering
    cl <- mfuzz(vsd.eset.ave.std, c = c_val, m = m_val)

    # save results to list
    key <- paste0("c", c_val, "_m", m_val)
    results[[key]] <- cl

    # # dynamic naming of file
    # filename <- paste0("cl", c_val, "_", m_val, ".pdf")
    # 
    # # save plot
    # pdf(filename)
    # mfuzz.plot2mod(vsd.eset.ave.std, cl = cl, mfrow = c(2,1), x11 = FALSE, centre=TRUE, centre.col="black", centre.lwd=2,
    #             time.labels = colnames(vsd.eset.ave.std),  cex.axis = 0.6, las = 2)
    # dev.off()
    # 
    # # Plot for genes witn membership >= 0.7
    # # dynamic naming of file
    # filename07 <- paste0("cl", c_val, "_", m_val, "minmem07.pdf")
    # 
    # # save plot
    # pdf(filename07)
    # mfuzz.plot2mod(vsd.eset.ave.std, cl = cl, min.mem = 0.7, mfrow = c(2,1), x11 = FALSE, centre=TRUE,
    #                centre.col="black", centre.lwd=2, time.labels = colnames(vsd.eset.ave.std),  cex.axis = 0.6, las = 2)
    # dev.off()
  }
}
# 
# 
# # Joined with overlap analysis below
# 
# # list of clustering results:
# # results[["c14_m1.20"]] <- cl14_120
# 
# # list to save overlap results
# overlaps <- list()
# 
# 
# for (key in names(results)) {
#   # for (key in names(results_csel)) {
#     
#   # cl <- results_csel[[key]]
#   cl <- results[[key]]
#     
#   # compute overlap
#   ov <- overlap(cl)
#   overlaps[[key]] <- ov
#   
#   # PDF file name eg. "c14_m1.20_overlap.pdf"
#   filename <- paste0(key, "_overlap.pdf")
#   
#   pdf(filename)
#   overlap.plot(cl, over = ov, thres = 0.05)
#   dev.off()
# }
```

### Plots in `eps` format

<!-- #### -->
```{r eps}
# Code for generation of clusters for selected ("final") parameters and drawing plots in eps format

library(Mfuzz)


c_val = 10
m_val = 1.25

## Uncomment on new session
load("../rdata-saved/vsd.eset.ave.std.samALLsig.RDa")

source("mfuzz.plot2_separate_lines.R") # modified plotting function, tailored to seprarate lines

    set.seed(1) # for reproducibility
    
    # clustering
    cl <- mfuzz(vsd.eset.ave.std, c = c_val, m = m_val)
    
    # dynamic naming of file
    
for (cluster in 1:10) {
    
    filename <- paste0("cl", cluster, "_", c_val, "_", m_val, ".eps")

    # save plot
    postscript(filename, horizontal = FALSE, onefile = TRUE, paper = "special", height = 3.8, width = 8)
    mfuzz.plot2mod(vsd.eset.ave.std, single=cluster, cl = cl, mfrow = c(1,1), x11 = FALSE, centre=TRUE, centre.col="black", centre.lwd=2,
                time.labels = colnames(vsd.eset.ave.std),  cex.axis = 0.6, las = 2)
    dev.off()
    
}
    
    # Plot for genes witn membership >= 0.7
    # dynamic naming of file
for (cluster in 1:10) {
    
    filename <- paste0("cl", cluster, "_", c_val, "_", m_val, "minmem07.eps")

    # save plot
    postscript(filename, horizontal = FALSE, onefile = TRUE, paper = "special", height = 3.8, width = 8)
    mfuzz.plot2mod(vsd.eset.ave.std, single=cluster, cl = cl, min.mem = 0.7, mfrow = c(1,1), x11 = FALSE, centre=TRUE, centre.col="black", centre.lwd=2,
                time.labels = colnames(vsd.eset.ave.std),  cex.axis = 0.6, las = 2)
    dev.off()
    
    
  # compute overlap
  ov <- overlap(cl)
  
  # PDF file name eg. "c14_m1.20_overlap.pdf"
  filename <- paste0(c_val, "_", m_val, "ovlap.eps")

  postscript(filename, horizontal = FALSE, onefile = TRUE, paper = "special", height = 8, width = 8)
  overlap.plot(cl, over = ov, thres = 0.05)
  dev.off()
    
}
    

```
<!-- #### -->

## Export results for chosen parameters

```{r selected}
# Use results from 'r check real' chunk

## Replace all occurrences of cluster name as needed ##

# all genes in clusters, without membership filtering
c10_m1.25 <- results[["c10_m1.25"]]

# this file contains only genes with mem >=0.7
genes_in_clusters <- lapply(1:ncol(c10_m1.25$membership), function(i) {
  geny <- rownames(c10_m1.25$membership)[c10_m1.25$membership[, i] >= 0.7]
  return(geny)
})

# Name clusters
names(genes_in_clusters) <- paste("Klaster", 1:ncol(c10_m1.25$membership))

save(c10_m1.25, genes_in_clusters, file="../rdata-saved/mfuzz_c10_m1.25_samALLsig.RDa")

```

## References