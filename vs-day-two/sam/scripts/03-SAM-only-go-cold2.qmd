---
title: "GO analysis for expression changes in SAM in cold, comparisons to 2nd day of cold"
format: html
date: "2025-07-09"
bibliography: refs-stat-anal.bib
execute:
  fig-format: png
  fig.dpi: 300
---

:::{.callout-note}
For html creation purposes I've turned off code execution.
:::

Built with R version `r getRversion()`

## R Preliminaries

Environment cleaning and set-up
```{r}
#| eval: false
#| output: false
#setwd("/media/mj/ANTIX-LIVE/project1-stat/scripts")
# Clean working directory
rm(list=ls())
```

```{r setup}
#| include: false
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(root.dir = "/home/mj/project1-stat/vs-day-two/sam/scripts")
```

## Files for GO analysis

Computation of median transcript length

```{r median length}
#| message: false

df <- read.table("../../../input-data/go/tran2gene2length", header = FALSE, col.names = c("ID", "Value"))

library(dplyr)

medians <- df |>
  group_by(ID) |>
    summarise(med = round(median(Value)))

# create list of genes and list of lengths
assayed.genes <- medians[[1]]

length.vec <- setNames(medians[[2]], medians[[1]])
length.vec <- setNames(as.integer(length.vec), names(length.vec))

# read GO categories

go.cats=read.table("../../../input-data/go/go.cats", header = TRUE, stringsAsFactors = FALSE)

# clean up
rm(df, medians)

```

Files for GO analysis
| object | description |
| --- | --- |
| `assayed.genes` | all known maize genes (from `gff`) |
| `length.vec` | median length of each gene in `assayed.genes` |
| `go.cats` | GO categories for each gene in `assayed.genes` |

:::{.callout-note}
These files are valid for a given genome annotation (genes in `gff` file) and GO annotation.
:::

Load the data from the significance test `02-leaf-only-loop-regr-cold.qmd ` (significant genes splitted by direction of change)

```{r load data}
#| message: false
load("../rdata-saved/sigs-SAM2.RDa")
```

## GO analysis

Using `goseq` package [@youngGeneOntologyAnalysis2010]

### Create a vector of significant genes

Get gene names

```{r de list lapply}
#| echo: false
#| message: false
# list of names
original_names <- grep("^[as].*(min|pl)$", ls(), value = TRUE)

prefix <- "de."

# get gene names
## invisible is used to suppress output in terminal

invisible(
  lapply(original_names, function(name) {
    obj <- get(name)                 # get object by name
    result=rownames(obj)           # get gene names
    new_name <- paste0(prefix, name) # create new name with prefix
    assign(new_name, result, envir = .GlobalEnv)  # save new object
  })
)

rm(original_names, prefix) # clean up

rm(list=ls(pattern = "^[as].*(min|pl)$")) # remove original objects

```

Create vector

```{r create vector lapply}
# list of names
original_names <- grep("^d.*(min|pl)$", ls(), value = TRUE)

prefix <- "gv."

# create vectors
invisible(
  lapply(original_names, function(name) {
    obj <- get(name)                 # get object by name
    result=as.integer(assayed.genes %in% obj)           # create vector
    names(result) <- assayed.genes  # set names to gene IDs
    new_name <- paste0(prefix, name) # create new name with prefix
    assign(new_name, result, envir = .GlobalEnv)  # save new object
  })
)

rm(original_names, prefix) # clean up

rm(list=ls(pattern = "^d.*(min|pl)$")) # remove intermediate objects
```

### Fitting the Probability Weighting Function (PWF)

```{r check data lapply}
print(length(length.vec))
print(anyDuplicated(names(length.vec)))

original_names <- grep("^gv.*(min|pl)$", ls(), value = TRUE)

invisible(
lapply(original_names, function(name) {
  obj <- get(name)                 # get object by name
  cat("Przetwarzam obiekt:", name, "\n")
  print(length(obj))
  print(anyDuplicated(names(obj)))
  print(all(names(obj) %in% names(length.vec)))
  print(all(names(length.vec) %in% names(obj)))
})
)

rm(original_names) # clean up
```

```{r pwf lapply}
#| echo: false
#| message: false
library(goseq)
# list of names
original_names <- grep("^gv.*(min|pl)$", ls(), value = TRUE)

prefix <- "pwf."

# create vectors
invisible(
  lapply(original_names, function(name) {
    obj <- get(name)                 # get object by name
    result=nullp(obj, bias.data=length.vec, plot.fit=FALSE)           # create vector
    new_name <- paste0(prefix, name) # create new name with prefix
    assign(new_name, result, envir = .GlobalEnv)  # save new object
  })
)

rm(original_names, prefix) # clean up

rm(list=ls(pattern = "^gv.*(min|pl)$")) # remove intermediate objects

```

```{r plots lapply}
#| warning: false
original_names <- grep("^pwf.*(min|pl)$", ls(), value = TRUE)

invisible(
plots <- lapply(original_names, function(name) {
  obj <- get(name)
  plotPWF(obj, main=name)
})
)

rm(original_names) # clean up
```

### Test

```{r goseq lapply}
#| message: false
#| output: false

# list of names
original_names <- grep("^pwf.*(min|pl)$", ls(), value = TRUE)

prefix1 <- "gs."
prefix2 <- "bh.gs."

# create vectors
invisible(
  lapply(original_names, function(name) {
    obj <- get(name)                 # get object by name
    result1=goseq(obj, gene2cat=go.cats, method="Wallenius", use_genes_without_cat=FALSE)
    result2=result1$category[p.adjust(result1$over_represented_pvalue, method="BH")<.05]
    new_name1 <- paste0(prefix1, name) # create new name (goseq result) with prefix
    new_name2 <- paste0(prefix2, name) # create new name (bh correction result) with prefix
    assign(new_name1, result1, envir = .GlobalEnv)  # save gs
    assign(new_name2, result2, envir = .GlobalEnv)  # save bh
  })
)

rm(original_names, prefix1, prefix2) # clean up

rm(list=ls(pattern = "^pwf.*(min|pl)$")) # remove intermediate objects

```

```{r export GO descr}
#| echo: false
#| message: false
library(GO.db)

# list of names
original_names <- grep("^bh.", ls(), value = TRUE)

invisible(
  lapply(original_names, function(name) {
    obj <- get(name)

    # Nazwa pliku na podstawie nazwy obiektu
    filename <- paste0("../results/go/", name, "sam.txt")

    # Rozpocznij zapisywanie do pliku
    sink(filename)

    # Dla każdego GO term wypisz do pliku
    for (go in obj) {
      print(GOTERM[[go]])
      cat("--------------------------------------\n")
    }

    # Zakończ zapisywanie
    sink()
  })
)

```

## Save objects

:::{.callout-note}
For use in EnrichmentMap App for Cytoscape
:::


```{r save objects example}
#| echo: false
# vectors of objects
#data1 = ls(pattern = "^a554_d[34].*(min|pl)$")
#data2 = ls(pattern = "gs.*a554_d[34].*(min|pl)$")

# concatenate
#to_save <- c(data1, data2, "go.cats")

# save
#save(list = to_save, file = "test_em.RDa")
```

```{r save objects}
# Saving results of goseq without BH correction (gs...) as objects after correction (bh...) contain only GO IDs with adjusted p-value below threshold
save(list = ls(pattern = "^gs."), file = "../rdata-saved/goseq-res_SAM2.RDa")
save(list = ls(pattern = "^bh."), file = "../rdata-saved/goseq-bh-res_SAM2.RDa")

```

Bar chart
```{r bar chart, fig.width=18, fig.height=6, dpi=300, dev='png'}
#| layout-nrow: 4
vector_names <- grep("^bh", ls(), value = TRUE)

library(dplyr)
library(purrr)
library(tibble)

# vector_names contains names of vector objects
result_df <- map_dfr(vector_names, function(name) {
  vec <- get(name)
  
  tibble(
    zbior = name,
    wartość = length(vec)  # convert to text
  )
})

library(tidyr)

result_df_clean <- result_df |>
  mutate(core_name = zbior,
  line = sub("^.*\\.(\\w+)_d.*$", "\\1", zbior)) |>
    separate(core_name, into = c("id", "day", "time", "tissue", "condition"), sep = "_")

library(ggplot2)

ggplot(result_df_clean, aes(x = zbior, y = wartość, fill = line)) +
  geom_col() +
  labs(title = "Number of overrepresented categories, color by line", x = "set", y = "count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

ggplot(result_df_clean, aes(x = zbior, y = wartość, fill = day)) +
  geom_col() +
  labs(title = "Number of overrepresented categories, color by day", x = "set", y = "count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

ggplot(result_df_clean, aes(x = zbior, y = wartość, fill = time)) +
  geom_col() +
  labs(title = "Number of overrepresented categories, color by time of day", x = "set", y = "count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

ggplot(result_df_clean, aes(x = zbior, y = wartość, fill = condition)) +
  geom_col() +
  labs(title = "Number of overrepresented categories, color by temperature", x = "set", y = "count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

## References